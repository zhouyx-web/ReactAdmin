1.在/路由下使用原生语法读取localStorage会出现跨域问题。

2.若浏览器的路径处于图形图表的某个路由下，刷新页面，会导致样式出错，高度不是100%。
    index.html下的css样式表路径去掉 . 

3.管理界面下在非/home路由刷新之后，默认高亮显示不是对应的菜单。
    将LeftNav组件包装成路由组件，就可以获得location属性了
4.当菜单的openKeys数组中的值为undefined时，子菜单打不开
    使用defaultOpenKeys属性
5.采用动态方式构建菜单组件，由于render函数会重复多次调用，所以构建函数也会多次调用，降低性能
    可以在组件的构造函数中初始化菜单项，这样菜单只会构建一次

day03
    1.用户登出时，使用this.setState({isQuit:true})没有生效
    使用this.setState(prevState => ({
            isQuit: true
        }))也不生效

    注：生效了，但是没有立刻获取到，使用this.setState({isQuit: true},() => {console.log(this.state.isQuit)})
    就可以立刻获取。页面没有跳转到/login是因为这个组件不是路由组件，使用withRouter包装一下就可以了
    
    二注：包装之后仍然，删除用户之后，仍然没有跳转，原因是登录界面是根据内存中的用户来判断的，但是
    内存中的用户没有被删除，所以又跳转到了管理界面，并不是组件是不是路由组件的问题

    三注：因为标题需要匹配左侧导航栏的显示，所以需要包装成路由组件获取pathname，根据导航菜单配置文件
    显示对应的标题，所以可以更加简便的直接操作history来进行页面跳转，不用使用重定向，也就不用维护
    一个isQuit的登录state属性

day05
    点击按钮获取子分类时，没有数据显示，采用的是先更新状态中的parentId，然后调用函数根据parentId作为
    参数获取列表，但是this.setState可能是异步更新，所以调用函数的时候parentId并没发生变化，仍然获取
    的是一级分类列表。
    解决：在this.setState的回调函数参数调用获取列表函数，就能保证使用的是新的parentId